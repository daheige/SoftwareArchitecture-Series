# 领域建模中的分层架构

在单体应用中我们熟悉的开发模式就是 MVC 三层架构：

![传统 MVC 分层](https://i.postimg.cc/3NJtdfYS/image.png)

在微服务架构模型比较常用的有几个，例如：整洁架构，CQRS（命令查询分离）以及六边形架构。每种架构模型都有自己的应用场景，但其核心都是“高内聚低耦合”原则。而运用领域驱动设计（DDD）理念以应对日常加速的业务变化对架构的影响，架构的边界越来越清晰，各司其职，这也符合微服务架构的设计思想。以领域驱动设计（DDD）为理念的分层架构已经成为微服务架构实践的最佳实践方法。

- 展现层：展现层负责向用户显示信息和解释用户指令，常表示客户侧相关应用。
- 用户接口层：用户接口层面向用户访问的数据入向接口，可按不同场景提供不一样的用户接口实现。面向 Web 的可使用 http restful 的方式提供服务，可增加安全认证、权限校验，日志记录等功能；面向微服务的可使用 RPC 方式提供服务，可增加限流、熔断等功能。
- 应用层：应用层是很薄的一层，主要面向用户用例操作，协调和指挥领域对象来完成业务逻辑。应用层也是与其他系统的应用层进行交互的必要渠道。应用层服务尽量简单，它不包含业务规则或知识，只为下一层的领域对象协调任务，使它们互相协作。应用层还可进行分布式和持久化事务控制或向外部应用发送基于事件的消息等。
- 领域层：领域层是软件的核心所在，它实现全部业务逻辑并且通过各种校验手段保证业务正确性。它包含业务所涉及的领域对象（实体、值对象）、领域服务以及它们之间的关系。它负责表达业务概念、业务状态以及业务规则，具体表现形式就是领域模型。
- 基础层：基础层为各层提供通用的技术能力，包括：为应用层传递消息、提供 API 管理，为领域层提供数据库持久化机制等。它还能通过技术框架来支持各层之间的交互。

![DDD 分层结构模型](https://s3.ax1x.com/2021/02/02/ynk13D.png)

代码模型最终结果来源于领域对象及服务矩阵：在代码模型设计时须建立领域对象和代码对象的一一映射，保证业务模型与代码模型的一致性，即使不熟悉业务的开发人员或者不熟悉代码的业务人员也可以很快定位到代码位置。基于 DDD 的代码模型包括 interfaces/controllers、application、domain 和 infrastructure 四个目录。

- interfaces（用户接口层）：本目录主要存放用户接口层代码。前端应用通过本层向应用服务获取展现所需的数据。本层主要用于处理用户发送的 Restful 请求和解析用户输入的配置文件等，并将信息传递给 Application 层。主要代码形态是数据组装以及 Facade 接口等。
- application（应用层）：本目录主要存放应用层代码。应用服务代码基于微服务内的领域服务或微服务外的应用服务完成服务编排和组合。为用户接口层提供各种应用数据展现支持。主要代码形态是应用服务和领域事件等。
- domain（领域层）：本目录主要存放领域层代码。本层代码主要实现核心领域逻辑，其主要代码形态是实体类方法和领域服务等。
- infrastructure（基础层）：本目录存放基础层代码，为其它各层提供通用技术能力、三方软件包、配置和基础资源服务等。

![各层请求的时序流](https://i.postimg.cc/9MnyXQTJ/image.png)

## COLA

COLA 的分层是一种改良了的三层架构。主要是将传统的业务逻辑层拆分成应用层、领域层和基础实施层。如下图所示，左边是传统的分层架构，右边是 COLA 的分层架构。

![COLA 架构模式](https://i.postimg.cc/0yvwYyXh/image.png)

其每一层的作用范围和含义如下：

- 展现层（Presentation Layer）：负责以 Rest 的格式接受 Web 请求，然后将请求路由给 Application 层执行，并返回视图模型（View Model），其载体通常是 DTO（Data Transfer Object）；
- 应用层（Application Layer）：主要负责获取输入，组装上下文，做输入校验，调用领域层做业务处理，如果需要的话，发送消息通知。当然，层次是开放的，若有需要，应用层也可以直接访问基础实施层；
- 领域层（Domain Layer）：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Entities）的函数对外部提供业务逻辑的计算和处理；
- 基础实施层（Infrastructure Layer）主要包含 Tunnel（数据通道）、Config 和 Common。这里我们使用 Tunnel 这个概念来对所有的数据来源进行抽象，这些数据来源可以是数据库（MySQL，NoSql）、搜索引擎、文件系统、也可以是 SOA 服务等；Config 负责应用的配置；Common 是通用的工具类。

# 领域服务

有些领域中的动作，它们是一些动词，看上去却不属于任何对象。它们代表了领域中的一个重要的行为，所以不能忽略它们或者简单地把它们合并到某个实体或者值对象中。当这样的行为从领域中被识别出来时，最佳实践是将它声明成一个服务。这样的对象不再拥有内置的状态。它的作用仅仅是为领域提供相应的功能。Service 往往是以一个活动来命名，而不是 Entity 来命名。

例如开篇转账的例子，转账（transfer）这个行为是一个非常重要的领域概念，但是它是发生在两个账号之间的，归属于账号 Entity 并不合适，因为一个账号 Entity 没有必要去关联他需要转账的账号 Entity，这种情况下，使用 MoneyTransferDomainService 就比较合适了。识别领域服务，主要看它是否满足以下三个特征：

- 服务执行的操作代表了一个领域概念，这个领域概念无法自然地隶属于一个实体或者值对象。
- 被执行的操作涉及到领域中的其他的对象。
- 操作是无状态的。

在使用领域服务时要特别当心，一个比较常见的错误是没有努力为行为找到一个适当的对象，就直接抽象成领域服务，这会使我们的代码逐渐转化为过程式的编程，一个极端的例子是把所有的行为都放到领域服务中，而领域模型退化成只有属性的贫血 DO，那 DDD 就没有任何意义了。所以一定要深入思考，既不能勉强将行为放到不符合对象定义的对象中，破坏对象的内聚性，使其语义变得模糊。也不能不加思考的都放到领域服务中，从而退化成面向过程的编程。

决定一个服务（Service）应该归属于哪一层是很困难的。如果所执行的操作概念上属于应用层，那么服务就应该放到这个层。如果操作是关于领域对象的，而且确实是与领域有关的、为领域的需要服务，那么它就应该属于领域层。总的来说，涉及到重要领域概念的行为应该放在 Domain 层，而其它非领域逻辑的技术代码放在 App 层，例如参数的解析，上下文的组装，调用领域服务，消息发送等。还是银行转账的 case 为例，下图给出了划分的建议：

# 渐进式能力下沉

在现实业务中，很多的功能都是用例特有的（Use case specific）的，如果盲目的使用 Domain 收拢业务并不见得能带来多大的益处。相反，这种收拢会导致 Domain 层的膨胀过厚，不够纯粹，反而会影响复用性和表达能力。所谓的能力下沉，是指我们不强求一次就能设计出 Domain 的能力，也不需要强制要求把所有的业务功能都放到 Domain 层，而是采用实用主义的态度，即只对那些需要在多个场景中需要被复用的能力进行抽象下沉，而不需要复用的，就暂时放在 App 层的 Use Case 里就好了。这里的 Use Case 是《架构整洁之道》里面的术语，简单理解就是响应一个 Request 的处理过程。

这种循序渐进的能力下沉策略，应该是一种更符合实际、更敏捷的方法。因为我们承认模型不是一次性设计出来的，而是迭代演化出来的。下沉的过程如下图所示，假设两个 Use Case 中，我们发现 uc1 的 step3 和 uc2 的 step1 有类似的功能，我们就可以考虑让其下沉到 Domain 层，从而增加代码的复用性。

![应用层能力下沉示意图](https://i.postimg.cc/pTv4kwcD/image.png)

指导下沉有两个关键指标：代码的复用性和内聚性。复用性是告诉我们 When（什么时候该下沉了），即有重复代码的时候。内聚性是告诉我们 How（要下沉到哪里），功能有没有内聚到恰当的实体上，有没有放到合适的层次上；因为 Domain 层的能力也是有两个层次的，一个是 Domain Service 这是相对比较粗的粒度，另一个是 Domain 的 Model 这个是最细粒度的复用。

比如，在我们的商品域，经常需要判断一个商品是不是最小单位，是不是中包商品。像这种能力就非常有必要直接挂载在 Model 上。

```java
public class CSPU {
  private String code;
  private String baseCode;

  //省略其它属性
  /**
   * 单品是否为最小单位。
   *
   */
  public boolean isMinimumUnit() {
    return StringUtils.equals(code, baseCode);
  }

  /**
   * 针对中包的特殊处理
   *
   */
  public boolean isMidPackage() {
    return StringUtils.equals(code, midPackageCode);
  }
}
```

之前，因为老系统中没有领域模型，没有 CSPU 这个实体。你会发现像判断单品是否为最小单位的逻辑是以 StringUtils.equals(code, baseCode)的形式散落在代码的各个角落。这种代码的可理解性是可想而知的，至少我在第一眼看到这个代码的时候，是完全不知道什么意思。

# TBD

- https://mp.weixin.qq.com/s/BAK4AjupwNW05nPUHRPILw
