# 设计理念

领域驱动设计的战略核心即是将问题域与应用架构相剥离，将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）转化为领域概念清晰的显性化表达出来。

- 统一语言，软件的开发人员/使用人员都使用同一套语言，即对某个概念，名词的认知是统一的，建立清晰的业务模型，形成统一的业务语义。将模型作为语言的支柱。确保团队在内部的所有交流中，代码中，画图，写东西，特别是讲话的时候都要使用这种语言。例如账号，转账，透支策略，这些都是非常重要的领域概念，如果这些命名都和我们日常讨论以及 PRD 中的描述保持一致，将会极大提升代码的可读性，减少认知成本。。比如不再会有人在会议中对“工单”、“审核单”、“表单”而反复确认含义了，DDD 的模型建立不会被 DB 所绑架。

- 面向领域，业务语义显性化，以领域去思考问题，而不是模块。将隐式的业务逻辑从一推 if-else 里面抽取出来，用通用语言去命名、去写代码、去扩展，让其变成显示概念；很多重要的业务概念，按照事务脚本的写法，其含义完全淹没在代码逻辑中没有突显出来。

- 职责划分，根据实际业务合理划分模型，模型之间依赖结构和边界更加清晰，避免了混乱的依赖关系，进而增加可读性、可维护性；单一职责，模型只关注自身的本职工作，避免“越权”而导致混乱的调用关系。通过建模，更好的表达现实世界中的复杂业务，随着时间的发展，不断增加系统对实际业务的沉淀，也将更好的通过清晰的代码描述业务逻辑，模型的内聚增加了系统的高度模块化，提升代码的可重用性，对比传统三层模式中，很有可能大量重复的功能散落在各个 Service 内部。

接触到需求第一步就是考虑领域模型，而不是将其切割成数据和行为，然后数据用数据库实现，行为使用服务实现，最后造成需求的首肢分离。以银行账号 Account 为案例，Account 有“存款”，“计算利息”和“取款”等业务行为，但是传统经典的方式是将“存款”，“计算利息”和“取款”行为放在账号的服务 AccountService 中，而不是放在 Account 对象本身之中。DDD 让你首先考虑的是业务语言，而不是数据。DDD 强调业务抽象和面向对象编程，而不是过程式业务逻辑实现。通过领域模型和 DDD 的分层思想，屏蔽外部变化对领域逻辑的影响，确保交付的软件产品是边界清晰的微服务，而不是内部边界依然混乱的小单体。在需求和设计变化时，可以轻松的完成微服务的开发、拆分和组合，确保微服务不易受外部变化的影响，并稳定运行。

## 设计原则

- Focusing on the Core Domain: DDD 强调需要将最多精力集中在核心子域上，核心子域是产品成败的关键，它的是产品的独特卖点，是它被建造而不是购买的原因。核心领域，将为您提供竞争优势，并为您的产品创造真正的商业价值，所有团队都了解核心领域是至关重要的。

- Learning through Collaboration: DDD 强调开发团队和业务专家之间合作的重要性，以产生解决问题的有用模型。如果没有业务专家的这种协作和承诺，很多知识共享将无法进行，开发团队也无法对问题领域有更深的了解。事实也是如此，通过协作和知识紧缩，企业有机会了解到更多关于其领域的知识。

- Creating Models through Exploration and Experimentation: DDD 将分析模型和代码模型视为一个整体，这意味着技术代码模型通过共享 UL 与分析模型绑定。这意味着技术代码模型通过共享 UL 与分析模型绑定。分析模型的突破会导致代码模型的改变。代码模型的重构，揭示了更深层次的洞察力，又会体现在业务的分析模型和心理模型中。只有当团队有时间去探索一个模型并对其设计进行实验时，才会有突破性的进展。花时间进行原型设计和实验，可以在很大程度上帮助你塑造一个更好的设计。它也可以揭示出一个糟糕的设计是什么样子的。埃里克-埃文斯建议，每一个好的设计至少要有三个坏的设计，这样可以防止团队停留在第一个有用的模型上。

- Communication: 有效描述为代表问题领域而建立的模型的能力是 DDD 的基础。这就是为什么，毫无疑问，DDD 最重要的一个方面就是创建 UL。如果没有一种共享的语言，业务团队和开发团队之间为解决问题而进行的协作就不会有效。团队之间在知识紧缩会议中产生的分析和心智模型需要一种共享的语言来将其与技术实现结合起来。如果没有一个有效的方式来沟通问题领域内的想法和解决方案，设计的突破就不可能发生。

- Understanding the Applicability of a Model: 建立的每个模型都是在其子域的背景下理解的，并使用 UL 进行描述。然而，在许多大型模型中，UL 内可能存在模糊性，组织的不同部分对一个共同的术语或概念有不同的理解。DDD 通过确保每个模型都有自己的 UL，且只在特定上下文中有效来解决这个问题。每个上下文定义了一个语言边界；确保模型在特定的上下文中被理解，以避免语言的歧义。因此一个具有重叠术语的模型被分为两个模型，每个模型在自己的上下文中被明确定义。在实现方面，策略模式可以强制执行这些语言边界，使模型能够孤立地发展。这些策略模式导致有组织的代码，能够支持变化和重写。

- Constantly Evolving the Model: 任何一个从事复杂系统的开发人员都可以写出好的代码，并在短时间内维护好它。然而，如果没有源代码和问题域之间的协同，继续开发很可能最终导致代码库难以修改，从而导致 BBoM。DDD 有助于解决这个问题，它强调团队要不断审视模型对当前问题的有用性。它挑战团队在获得领域洞察力时，对领域的复杂模型进行进化和简化。DDD 仍然不是什么灵丹妙药，需要奉献精神和不断的知识紧缩，才能生产出可维护多年的软件，而不仅仅是几个月。新的业务案例可能会打破以前有用的模型，或者可能需要改变，使新的或现有的概念更加明确。

## 概念澄清

- DDD 不是一个框架，更非单纯的技术解决方案，绝不是引入某个包就可以实现的。

- DDD 并非银弹，我们实践 DDD 的根本目的也是为了更快、更好地满足业务不断迭代的需求，并且能够保证团队的延续性与表述一致性，譬如对于问题域中相同变量、指标的定义是一致的。DDD 不适合多数为 CRUD 单表操作的简单业务场景，在该场景下往往导致增加系统复杂度。同样不适合基于老系统代码之上进行的优化重构，因为这样从传统分层模式到基于聚合的设计是完全颠覆性的，论改造成本不如重新开发一套新应用。

# DDD 价值

Eric Evans 在创造性地提出领域驱动设计时，实则是针对当时项目中聚焦在以数据以及数据样式为核心的系统建模方法的批判。面向数据的建模方法是关系数据库理论的延续，关注的是数据表以及数据表之间关系的设计。这是典型的面向技术实现的建模方法，面对日渐复杂的业务逻辑，这种设计方法欠缺灵活性与可扩展性，也无法更好地利用面向对象设计思想及设计模式，建立可重用的、可扩展的代码单元。领域驱动设计的提出，是设计观念的转变，蕴含了全新的设计思想、设计原则与设计过程。

## 应对复杂业务

引起软件系统复杂度的主要因素是需求，软件系统需求又可以分两个方面：业务需求和技术需求。我们分析系统的复杂度时就可以从业务复杂度和技术复杂度这两个维度出发。

业务复杂度跟系统的业务需求规模和需求之间的关系层级有直接关系，需求的数量和关系的层级决定代码的规模和逻辑循环或递归的层级，系统的需求数量越大，需求之间的关系越复杂，系统的业务复杂度就越大。John Ousterhout 的著作《A Philosophy of Software Design》从认知的负担和开发工作量的角度来定义软件系统的复杂度，并给出了一个复杂度公式：

$$
C=\sum_{p} \mathrm{C}_{p} \mathrm{t}_{p}
$$

子模块的复杂度（cp）乘以该模块对应的开发时间权重值（tp），累加后得到系统的整体复杂度（C）。可以看到系统整体的复杂度并不简单等于所有子模块复杂度的累加，还要考虑该模块的开发维护所花费的时间在整体时间中的权重占比（tp），这个权重比就跟模块划分是否内聚、设计是否优雅有直接关系。

DDD 的核心思想就是要避免业务逻辑的复杂度与技术实现的复杂度混淆在一起，确定业务逻辑与技术实现的边界，从而隔离各自的复杂度，业务逻辑并不关心技术是如何实现的。无论采用何种技术，只要业务需求不变，业务规则就不会变化。理想状态下，应该保证业务逻辑与技术实现是正交的。DDD 通过分层架构与六边形架构确保业务逻辑与技术实现的隔离。
