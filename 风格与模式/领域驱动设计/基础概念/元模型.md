# 元模型

在 DDD 中，我们可以把名词分为战术设计(Tactic DDD)与战略设计(Strategic DDD)两类，战略设计更大一些，偏宏观，你可以理解为公司高层在讨论的业务和技术方向，各个团队或者产品的分工和配合；而战术设计则相对小很多，主要集中在一个 BoundedContext 内部，比如如何设计 DDD 那些 Entity，Service，Repository 等，外加可能的应用开发的技术选型，可以说更关注技术层面。战术设计与战略设计的相关名词划分如下：

- 战术设计(Tactic DDD)：Entity, Value Object; Aggregate, Root Entity, Service, Domain Event; Factory, Repository。

- 战略设计(Strategic DDD)：Bounded Context, Context Map; Published Language, Shared Kernel, Open Host Service, Customer-Supplier, Conformist, Anti Corruption Layer (context relationship types)。

![DDD 关键术语关系图](https://s3.ax1x.com/2021/02/02/ynTk7R.png)

领域驱动设计围绕着领域模型进行设计，通过分层架构（Layered Architecture）将领域独立出来。表示领域模型的对象包括：实体、值对象和领域服务，领域逻辑都应该封装在这些对象中。这一严格的设计原则可以避免业务逻辑渗透到领域层之外，导致技术实现与业务逻辑的混淆。在领域驱动设计的演进中，又引入了领域事件来丰富领域模型。聚合是一种边界，它可以封装一到多个实体与值对象，并维持该边界范围之内的业务完整性。在聚合中，至少包含一个实体，且只有实体才能作为聚合根（Aggregate Root）。注意，在领域驱动设计中，没有任何一个类是单独的聚合，因为聚合代表的是边界概念，而非领域概念。在极端情况下，一个聚合可能有且只有一个实体。

工厂和资源库都是对领域对象生命周期的管理。前者负责领域对象的创建，往往用于封装复杂或者可能变化的创建逻辑；后者则负责从存放资源的位置（数据库、内存或者其他 Web 资源）获取、添加、删除或者修改领域对象。领域模型中的资源库不应该暴露访问领域对象的技术实现细节。

![DDD 关键术语对比](https://i.postimg.cc/1X77QS5Q/image.png)

# 战术设计

## Entity（实体）

每个实体是具有唯一标识的领域概念，并且可以相当长的一段时间内持续地变化。例如实体订单 Order，标识为 oderId，活动实体 Activity，标识为 activityId，客户实体 Customer，标识为 customerId。假设每个客户都有一个或者多个收货地址（包括国家、省、市、村、楼号、单元）等等，作为客户实体的一部分携带的业务属性，可以进一步提取为地址值对象，一对多关联，用以保证最关键的业务含义在实体身上，控制每个领域对象的粒度最小，避免属性过多导致模型混乱，结构不清晰。

我们可以对实体做多次修改，故一个实体对象可能和它先前的状态大不相同。但是，由于它们拥有相同的身份标识，他们依然是同一个实体。例如一件商品在电商商品上下文中是一个实体，通过商品中台唯一的商品 id 来标示这个实体。

## ValueObject（值对象）

当我们只关心一个模型元素的属性时，应把它归类为值对象。应该使这个模型元素能够表示出其属性的意义，并为它提供相关功能。实体与 VO 的区别在于唯一的身份标识和可变性。当一个对象用于描述一个事物，但是又没有唯一标示，那么它就是一个 VO。例如商品中的商品类别，类别就没有一个唯一标识，通过图书、服装等这些值就能明确表示这个商品类别。

建议将值对象设计成一个不变（Immutable）对象，这样就不需要担心并发带来的诸如同步、冲突等问题了，这既降低了编程的难度，又可以无需引入额外的同步锁影响程序的性能。也不要为它分配任何标识，这样应用也无需去管理值对象的生命周期。值对象通过比较其属性（equals）区分是否是相同值对象。应该尽量使用值对象来建模而不是实体对象。

在领域驱动设计中，提倡尽量定义值对象来替代基本类型，因为基本类型无法体现统一语言中的领域概念。假设一个实体定义了许多属性，这些属性都是基本类型，就会导致与这些属性相关的领域行为都要放到实体中，导致实体的职责变得不够单一。引入值对象后情况就不同了，我们可以利用合理的职责分配，将这些职责（领域行为）按照内聚性分配到各个值对象中，这个领域模型就能变得协作良好。值对象可以与其所在的实体对象保存在同一张表中，值对象的每一个属性保存为一列；值对象也可以独立于其所在的实体对象保存在另一张表中，值对象获得委派主键，该主键对客户端是不可见的。

## Aggregate（聚合）与 Aggregate Root（聚合根）

聚合是具有一定关联关系的实体对象的集合，用来划分实体之间的边界，使模型之间更加内聚，边界更加清晰，定义清晰的聚合有助于避免混乱的模型关系划分导致模型之间错综复杂的关系网。抛除概念，可以理解为一组有关联关系的数据单元，聚合的加载、修改、销毁作为一个整体进行。

而聚合根是聚合的边界，是与外部打交道的唯一入口，聚合内部实体对象或值对象保持被聚合根引用，不可被其他聚合操作引用，也不能单独进行查询。聚合根是一种更大范围的封装，把一组有相同生命周期、在业务上不可分隔的实体和值对象放在一起考虑，只有根实体可以对外暴露引用，也是一种内聚性的表现。聚合内部的实体也有可能引用其他的聚合根。由此特性可得，聚合根的查询，在 DB 层面也应该是一个单元，聚合根被删除，整个聚合也会被删除（基本等于级联删除）。

比如“公司”、“老板”、“员工” 就是一个聚合，有独立存在的意义，不依赖其他对象存在，能够被独立访问到的从这三个实体来看，公司为聚合根，公司倒闭了，雇佣的员工和老板也就不存在了。另外，快递员会每天往公司投递货物，两者之间并无直接关联，因此快递员是隶属于另外聚合中的一个实体，或独立为只有一个实体的聚合的根。因此聚合和根的设定需要在实际业务角度深入分析。

通常在大多领域模型中，多数聚合只有一个实体，即聚合根，该实体内部只包含一部分值对象，另外少数聚合中也只有两三个实体引用。聚合尽可能粒度控制不要太大，否则为在事务级别做到聚合完整性，性能代价较大。

## 工厂（Factory）

有时候创建领域对象不仅仅是简单的 new 操作，比如创建是需要一系列初始化工作，对参数进行一些业务规则校验，如果参数无效不能创建期望的对象时抛出一个异常等，而这些规则属于领域层的业务，我们不希望暴露给应用层更多的领域规则，这就需要将这些细节进行一次封装，而在 DDD 中没有其他元素适合这一工作，于是出现了工厂这一概念。隐藏创建对象的好处是即不会污染应用层，又避免泄露领域层规则，只需要对外暴露简单的方法，外部传入创建所需的参数即可。

## 仓储（Repository）

由于聚合的特性，我们需要一并加载聚合实体到内存，也需将聚合整体持久化到 DB 中，我们又不希望直接在业务编码中直接编入如何获取数据的代码，于是产生出这一元素，负责聚合的加载与持久，对外提供简单的接口调用。仓储内部持有的一定是聚合，原因是在 DDD 中模型是以聚合划分的，实体的组建与持久依赖于所在聚合，模型不能够脱离聚合单独创建，因此仓储的设计也应该从聚合角度出发，我理解的仓储就是聚合的管理器，它的定义仅是一个接口，实现方式任意替换而不影响上层调用者。

抛除概念，从实际开发角度，仓储是领域模型与 ORM 工具中间的协调器。例如传统贫血模型中，DAO 通过 ORM 工具将表映射为对应的 DO(数值对象)，而 DDD 中模型以聚合为边界划分，而碍于历史原因或性能需要，表结构往往与聚合结构有较大区别，仓储就是为了协调这种 DB 于模型之间转换而提出的概念。

如果系统并非用 DDD 方式建立模型, 而对象的加载使用 Repository 方式查询，则有些不伦不类，这样与 DAO 无任何分别，因为模型是贫血模型而非聚合。包的划分，仓储接口定义在领域层，实现在基础设施层。在传统 DDD 中一般由应用层引用仓储，而在 CQRS(DDD 针对因系统中存在大量复杂查询导致不得不跨聚合查询的一种优化模式)中一般由 Command 引用。

# 战略设计

领域驱动设计的战略设计阶段是从以下两个方面来考虑的：

- 问题域方面：针对问题域，引入限界上下文（Bounded Context）和上下文映射（Context Map）对问题域进行合理的分解，识别出核心领域（Core Domain）与子领域（SubDomain），并确定领域的边界以及它们之间的关系，维持模型的完整性。
- 架构方面：通过分层架构来隔离关注点，尤其是将领域实现独立出来，能够更利于领域模型的单一性与稳定性；引入六边形架构可以清晰地表达领域与技术基础设施的边界；CQRS 模式则分离了查询场景和命令场景，针对不同场景选择使用同步或异步操作，来提高架构的低延迟性与高并发能力

## Bounded Context（限界上下文）

用来封装通用语言和领域对象，为领域提供上下文语境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。使团队所有成员能够明确地知道什么必须保持一致，什么必须独立开发。

## 事件风暴（Event Storming）

事件风暴是一项团队活动，旨在通过领域事件识别出聚合根，进而划分微服务的限界上下文。在活动中，团队先通过头脑风暴的形式罗列出领域中所有的领域事件，整合之后形成最终的领域事件集合，然后对于每一个事件，标注出导致该事件的命令（Command），再然后为每个事件标注出命令发起方的角色，命令可以是用户发起，也可以是第三方系统调用或者是定时器触发等。最后对事件进行分类整理出聚合根以及限界上下文。

## 共享内核（Shared Kernel）

如何实现不同域之间的协作，同时又要保证各自领域的概念的完整性是有一套方法论的。总体来说，大概有两种方式：共享内核（Shared Kernel）和防腐层（ACL，Anti-Corruption Layer）。

It’s possible that only one of the teams will maintain the code, build, and test for what is shared. A Shared Kernel is often very difficult to conceive in the first place, and difficult to maintain, because you must have open communication between teams and constant agreement on what constitutes the model to be shared.

![](https://i.postimg.cc/y6D9BmZv/image.png)

其优点是 Share（减少重复建设），其缺点也是 Share（团队之间紧耦合）。

## 防腐层（ACL，Anti-Corruption Layer）

An Anticorruption Layer is the most defensive Context Mapping relationship, where the downstream team creates a translation layer between its Ubiquitous Language (model) and the Ubiquitous Language (model) that is upstream to it.

![](https://i.postimg.cc/50q9FYMH/image.png)

防腐层是隔离最彻底的做法，其优点是没有 Share（完全解耦，各自独立），其缺点也是没有 Share（有一定的转换成本）。笔者比较赞成防腐层的做法，因为增加的语义转换陈本，相较于系统的可维护性和可理解性而言，是完全值得的。

Whenever possible, you should try to create an Anticorruption Layer between your downstream model and an upstream integration model, so that you can produce model concepts on your side of the integration that specifically fit your business needs and that keep you completely isolated from foreign concepts.
